\section{Methods}

\subsection{Version Control}
Blender recently switched from SVN\cite{svn} to Git\cite{git} as its version control system\cite{blendergit}.
The main Git branch for Blender is its ``master'' branch.
This project makes use of a repository cloned to GitHub\cite{github}, where a ``thesis'' branch was also created.

\subsection{Benchmark Platform}
\label{sec:bench_platform}
\ifsummaries
\begin{itemize}
 \item Arch Linux (3.12.5 64bit kernel)
 \item Intel Core i7 Q 740 CPU running at 1.73GHz
 \item 8GB of DDR3 RAM
 \item NVIDIA GeForce GT 425M GPU
 \item GCC 4.8.2
\end{itemize}
\fi

\todo{Need something besides the summary here. Maybe a table? Or leave this as bullets? Either way, some text needs to be added to preface the information.}

\subsection{Benchmark Scene}
\label{sec:bench_scene}
\ifsummaries
\begin{itemize}
 \item 160 Skeletal Meshes
 \item Each skeleton has sixty-nine bones, and each mesh has 4,951 vertexes
 \item Directions for running the scene
\end{itemize}
\fi

The scene used to benchmark performance changes is comprised of 160 skeletal meshes.
Each of these skeletal meshes contains a sixty-nine bone armature and a mesh with 4,951 vertexes.
All 160 skeletal meshes perform the same animation, which is a silly dance animation.
However they each have their own skeleton, and each skeleton's pose update is done independent of other skeletons.
Therefore, this benchmark can still be representative of multiple different characters performing different actions.
The scene also has no physics being calculated, which allows the characters to freely clip into one another.
A screenshot of the scene being run is shown in figure~\ref{fig:anim_bench}.

\fig{imgs/anim_heavy}{0.5}{Screenshot of the benchmark scene}{anim_bench}

The benchmark scene will be run through the stand-alone Blenderplayer instead of the embedded player using the following settings:
\begin{verbatim}
blenderplayer -w 1600 900 -g show_framerate = 1 -g show_profile = 1 anim_stress.blend
\end{verbatim}

Another version of this scene, which is accessed by adding \texttt{- random} to the end of the above command line string, assigns a random action to each character.
While this version is not as consistent as the original scene (making it poorer for benchmarking), it does help to visually verify that duplicates of the same character can play different actions.
In other words, to show that the threaded code is not breaking when used with different actions.

\subsection{Measuring Performance}
\ifsummaries
\begin{itemize}
 \item BGE profiler for frametime/fps
 \item gperftools for profiling
 \item nvidia-smi for measuring GPU utilization
\end{itemize}
\fi

\todo{Fill out this section}

\subsection{Verification}
\ifsummaries
\begin{itemize}
 \item Helgrind for detecting threading errors
 \item Valgrind for detecting memory errors
\end{itemize}
\fi

Helgrind (part of the Valgrind suite\cite{valgrind}) can be used to check for threading errors.
According to the Helgrind manual\cite{hgmanual}, Helgrind can detect the following three classes of errors:
\begin{enumerate}
 \item Misuses of the POSIX pthreads API
 \item Potential deadlocks arising from lock ordering problems
 \item Data races -- accessing memory without adequate locking or synchronization
\end{enumerate}

Since OpenMP is being used for parts of this work, as noted in section 7.5 ``Hints and Tips for Effective Use of Helgrind'' of the Helgrind manual\cite{hgmanual}, GCC needs to be built with the \texttt{--disable-linux-futex} option for accurate output when using OpenMP.

\todo{Talk about Valgrind's memcheck tool}
